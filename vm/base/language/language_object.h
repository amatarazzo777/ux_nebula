/*
 * This file is part of the ux_nebula distribution
 * (https://github.com/amatarazzo777/ux_gui_stream).
 * Copyright (c) 2023 Anthony Matarazzo.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */


/*

The base language object, all parsers derrive from this functionality to 
have much less code within their source tree. For example, all parsers
for every language can use the file input, memory input, token to ast node,
Generalized AST nodes, such as function call, object call, import modules,
text rendering, document building, file system, time formating, user interface,
network protocols, databases, etc can use the same or functional base. The 
ability to functionally operate on calling objects and calling conventions 
using the ABI. Supporting template typed inlined algorithms for building block
application requirements, vector, array, searching, sorting and memory management 
as an inlined resource. There are better and more efficient means to utilize 
the connections, no error checking at all can be faster. This is one reason
null was placed into the world. 

If a CPU could advance index position, 
repeat a number of times faster than checking for the condition each time.
Automatic advancing by after use signaling is a type of circuit design. The 
processor must incorporate this behavior. Multiple instructions can be sped
up using hinting as a type of specific memory mov. 
That is, hint bit for double mov. Loading pointer memory from storage as per 
instruction. Therefore a hinting series on statement context changes from
programming languages can also instruct the flow of machine operation better. 
The hint system, and how to integrate it with the processor. 

Algorithms that are tuned for the system are well liked. Often the perfect mix
is the ability to apply the mechanism is a scaled way. Often for simplicity,
some algorithms are applied serially. Summarization, node finding, indexing,
data storage. 

Processors of modern day have specialized memory internally to act as 
an object. Basic Math, comparrison, are most essential instruction jump.
Access for memory, the hugh number we all hear about, is rooted in
problems. They are solved with specialized parameters, and also instructions.
The main breaking from the RISC model, is the CISC. CISC implements the 
ability to combine a memory address, and a register for an instruction. Whereas
RISC uses a separate instruction to reference main memory. Simply adding a hint,
mechanism can be far reaching for speed improvements. Thereby surpasing the 
CISC mechanical implementation. Introducing context INT tables for higher level
device operations. BIOS has drivers that are compiled for the layer, npt wasting the 
design. That is BIOS usage as a map from user APIs. Preserving
the use of the instruction saves memory. Instruction context changing for 
decoding smaller program memory.

In this project, using the LLVM provides a CPU, while considering some
basic prociples. As well, for multiple consolidated system tasks, some instructions
are handled elsewhere by assembly or object code. Depending on the linux 
POSIX base provides methods where booting and many system functions are
handled.

Languages such as C and C++ are losely modeled on CPU instruction sets
providing a great order to multiple facets of know CPU instructions.
The names or operators consolidated to machine code operators. STL,
provides a higher level of low level algorithms. Yet C, or C++ does not 
define many other aspects of output. A very basic system. Cython, the 
orginal version of python language, offers other descriptive abilities. 
The languages of modern day are not as organized as they can be. A
few developed and are promoted but simply enhance a type of 
processing, yet leave out c, c++ base features as being too complex
for language. Mutex, structures, pointers, and inheiritance. 


Many times the workings of algorithms and the styled language offer poor performance.
Even as a programmer, people would not want to design things in a hardware, computer,
os way because of best practices and maintain ability solutions. For example, 
many types of thread signaliing against a list can increase searching work, 
where some of the participants waiting for the signal are near within the current search. 
By dispatching to neighbors this information, some types of searching speed can be increased. 
This can be handled by the base database_t format, using a memory database that is shared, 
or promoted to shared and reattached to systems as a thread enabled container and object
operators for cross language, advanced designs furfilling c++ to OS object and module loading.
Providing dynamic late time bindings. Using advanced POSIX OS features where the standard
library stops. The relationship of C, to linux is provided in its API as a native. Simply
the cstandard library reintroduces these through functions, adopted as a type of formatter.
Most derivatives are naming to the console and string methods. To be cross platform, the 
standard template librarys are introduced to select api calls. At times, the lacks
performance where native POSIX calls can be more effective. The implementation of buffering
for example, is applied at a new layer within the c++ system. The POSIX system
applies this already, doubling the work effort occuring in most c and c++ programs.


Mutex and multithreaded programming with memory management and UI, database etc. Thread 
pool and interface abstraction to using this concept is easy. Thread pool manager has a 
metric for balance, low and high. The ow number of threads is known to be available.
The high number is limit before signal wait. Each algorithm step needing work is added
to the queue of the thread pool manager. It has the abstract interface and within the 
c++ class has the function filled with multitasking. Often types of objects perform
certain types of work. One called PDF, Dta, Report, etc. As parameters, the constructor
adopts the object to utilizing those resources. The resources must be locked while 
reading or writing to them. Mutex provides this functionality, while signal wait provides the 
fastness of immediately starting after an update. For example the thread pool manager would 
continuing looping and then wait until there is no work being requested in the queue. Advancements
in system processes of thread pools can even tie two together before proceeding to the next.
 Logic processing is a described, modeled and then generalized.

 Languages can also use the AST and BISON facilities along with this to make languages inside their 
 language. There is another parser, that is written java, named ANTLR4 than also produces
 parsers. As well an execellent BNF parser generator that is perfect for the jobs. A library
 written in boost, that allows the description and logic of the parser to be inside a c++
 program. The mechanisms for describing the words, and matching offer simular operators when
 considering BISON. So for example, one may take a source text format, and generate a c++ program
 using the boost library. Compile it as an object. Develop the language as a target may offer that 
 some types of not all parts are in existance. Yet a recognizeable "process chain" file template implementation
 provides the fill in c++ objects for implementation. Providing many advanced algorithms and 
 consolidation. Perhaps for some types of language definition there would be a separate set 
 of file or archiecture types. Where as a simplier inheirtance based language provides. So it seems that perhaps a specific implementation that utilizes the knownledge
 of parser generation, and increases the performance.

 The Source code compiler for the system dispatches the compiler to multiple layers of parsers and 
 data segment or structure generators utilizing the clang base is a positive direction. Clang is
 provisioned with types of expansion capabilities that make it suited. Yet offering these deviate from
 standard. As types of advancements, some are held captive as too long lived and become old.
 To provide directions away yet remain within the C++ design is essential. Yet neverbefore has
 the oppurtunity existed in previous technology as a product using LLVM has. Simply by 
 advancing upon the clang engine with minimal changes allows reintroduction of existing
 known AST tree code that is function. It is interesting to reutilize the same 
 API calls to populate the AST tree from parsing other languages. Therefore the ability
 to integrate the clang compiler with other parsers that yield, is a very
 favored task of a developer machine. 
 
 That is writing a bison for a language advancement, and use the AST builder, llvm generated
 assembly tokenizer, with a single visit routine in the language implementation. To minimize
 language and provide filling out requirrements typical, of building user defined types 
 that operate with objects or api inside the language. The facilities, once
 installed are available as a temporary resource, or as a system language. Perhaps security
 is of one concern and language dissemination. Installing it as a base language, may be improper.

 Often languages do not get developed because they are for a small pertinent purpose. Requireing
 specific focus in a field, such as described. Yet as necessary, the ability to automate the 
 process from one form, provide language building constructs to include, and establish also
 linking to the visitation. This consolidates functions and real time language creation narrows 
 the field. Perhaps it is not a function used all of the time without planning. Often
 groups start that proceed development with specifics of advancements. Coverage of a general
 purpose programming language can be tedious. The recursive node structure of the AST
 and LLVM context provide for a visitation format. The consideral arguments are language 
 specification, and also elemental types. 

 Choice of variable constructs, object calling and inheiritance routes. Defining
 inline algorithms specific to known data type, reducing structure walk through,
 and also cross conversion with formatting. The provisions of solving a
 type of user defined type and its capabilities for container, indexing, and also
 formatting as an inlined resource yet drawn from definition sources is exciting
 in performance gains. There are many reasons this has not been done in the past
 primarily due to the ease of LLVM and register accountability. 

 Languages define often a structure for memory protectiond, or other relationships 
 that guard against syntax. The proclaimination is not necessary often in binary
 machine code. Simply the logic produce from the assembly does not contain the 
 regarded operations as sought by describing in the computer language. So the 
 construct of the running program can operate witout error checking of this sort.
 Global variables are the mainstay. The reduction in stack and heap space
 are often refferenced in garbage collection. An effective logical 
 path coverage through the program can progressing find variables that are 
 inline to be utilized many times, or have multiple states in a stack. 



 A very important concept of performance settlement at the level, is data and 
display transformation, data formatting, and creation of linked document object model.
Using the XSLT and XML methodology for a starting point, the formatting and display
of data, interface objects, and events have to be infused with the data. As a known
of editing, or display, formatting, with shape draing, shading, image processing,
communicated to the pipeline. Templates do provide the unraveling of the object.
Notible Element, and types of behaviour associated with it. As a structure, class,
creating it within the language as LLVM developed structure, could mean usaing 
several select methods. The necessity of developing a lower level, interface
for the display and rendering to be written in c++ using only structs, and readible
known formats. The element structure has node access using raw pointers. Most
structures such as style and attribute, can also be inscribed. As a facility,
the calls to specific types of rendering technology through native ABI and raw memory
is compatible with BC coding. Therefore, integration of a system to document trees
and language implementation can be selective and also high performance. This adds to 
the design, but strengthens some code bases such as the base document object model from
c++. It utilizes its own interface layer to native language integrate to the new 
raw memory compunent for language filling. 

When the tri compund of multiple types of algorithms working together, often knowing the 
bounds of search provides efficiency. For example string searching using regular expression
is a known method. It is sometime tedious to develop large matching patterns. In this way
bison is more advanced. The ability to develop a parsing engine that is efficient and 
will link to inheirited and described language features using the BISON format provides
efficiency of LLVM. The parser made for memory buffer only.

The ability for operators and statements to be communicative with the inline algorithm
production facilities provides a means to companion emittances of the operations. A production
facility is also to deviate from the prescribed calling conventions internally such that 
protocol endeavours may be made possible. The design should allow for during emittance,
the operator for the algorithm, adjusted for parameter usage, data type, will also include 
added types. For example, the amount of calls for data and time, as a numerical representation,
can be verily reduced as an inline advanced data type. Distributed in all systems even storage.
As a base date/time numeric with a designed output format integrated, inline compileded using 
recursion for set formats. Ingregal information qualities extrapolated, and bit wise manulipated.
Outformat also has length stay with the Local setting. 

Number formating and advanced rounding storage types, integrated with the assembler. Formatting
routines with sizes and DOM node compatibility for styled inheirited display, target built.These 
things never change in the display necessity. If one writes the code to change over also,
in the language, then that genetic code path will contain the genetic type. Merely providing
the facility provides the fastest build up method for select.

Every boolean in the entire land, changed to a bit could be a target for program. Although
memory contention could arise from several threads a program would create and expect memory. 
Too bad.


The compiled programs are going to be attached to a document object model, already made
where epilogue and prolog code interact with the device or operating system. Simply
the structure now is one c++ box, with the systems embedded in one project. If everything
links down to the base_function_call stack, the API for applications as a direct
memory structure that is read only, one would want to design the base
platform as such. Most of the provisions of the applications should be 
alloted for types of protected access. There is a handful of useful
API, and many subsequent systems embark upon creating summarizations
aut automations of these. In this, base systems have a root to be named well.

The database system, precludes all storage formats of structure system wide.
No more text user settings, network settings, or text driver programs except
language. The file system, and database system are perhaps types that 
are genetically transcribed to run within a checked context. Yet at this level,
still using the opened file handles that are native to linux can be functional.
Yet opening and closing the file associated with a restriction on application layers.
For system use, perhaps it may be performed at a low level. Device driver
implementations for better throughput. 

A genetic template language for algorithm description that can be utilized
with llvm is necessary. Otherwise the stack of calls to embed calls to other systems, 
in sequence for a process becomes tedious. Algorithm description and data
types. The language will have no display or network capabilities, formatting of 
string, numerics, floating points, time, date, and also c++ dom all toegether
in one format, and template for creating inline data types. 
An interesting concept is to utilize the c++ compiler without any std includes but 
write the functions for multiple languages, and containers, operators, the base structure
as a hand carved c++ template. Use clang to fill the tree, and develop a
codebase that transfer langage to c++, using their native internal functions. 

Ultimately multiphase compiling and analyzation is a stray away from how computer scientists
propel their magic with compilers. Compilings has to be fast. Yet the ability to utilize more 
analysis, almost unlimited, has also its value as output. That is, from the analysis, more 
efficient executing programs with additional features. 

*/

namespace viewManager {
  enum_algorithm_t {
    data_type,
    inline_data_type,
    api_call,
  };

class computer_language_abstract_t {
  std::vector<std::string> lines_of_code;
  ASTNodes *node;
  std::vector<std::string> grammer;

  // ast nodes with inline genetic algorithm for variables,
  // handling vector, list, unordered map, ordered map, nad partial search map
  void emit_object_type(ASTNode *node, enum_datatype_t a);
  void emit_object_type_inline(ASTNode *node, enum_datatype_t a);

  // api call to c++ base.
  void emit_api_call(ASTNode *node);

  // an inline system kernel call headers found i nthe <sys> directory.
  // the includes, advanced features of the file system, process,
  // thread, mmap mapfing a file to memory, shared memory,
  // scatter gatter io, and socket communication and pipes.
  void emit_inline_posix_call(ASTNode *node);

  void emit_document_object_inline(ASTNode *node);
  void emit_document_object_inline(ASTNode *node, const std::string &markup);
  std::size_t emit_create_memory(unsigned char *b, std::size_t size, bool bmutex);
  std::size_t emit_create_object(unsigned char *b, std::size_t size, bool bmutex);
  void emit_free_memory(size_t id);


  // generates an llvm component for the BISON language, 
  // can be a cached object of machine code for parser. 
  void gencode_grammer_tokenizer(void);

  void generate_parser(void);

  /*
  The generate build system provides the capability to store languages
  as an object for library, and local usage. Ultimately, this is at the system level,
  using provisions upstream must safe guard this system. Many of the facilities 
  can be reutilized. Multiple languages, an IDE that utilizes better
  compiling and project management for c++.

  In general, this system intends to strengthen the datatype output, to be 
  of a more structured format. As well applying the facilities of the document object model and 
  sgml.
  */
  void generate_build_system(void);

  /*
    Source indexer is a facility that provides autocompletion. Source
    index is also a great name, for the documentation system perhaps. 
  */
  void generate_source_indexer(void);

  /*
  There are multiple documentations formats, the lasting doxygen is useful.
  As well, the proximity to expand within IDE, true doocumentation, as a 
  function inline editing component can provide other useful systems.
  Visual communication using drawing, or more likely presented in a
  documentation tool.*/
  void generate_language_documentation(void);
  void generate_ide(void);
  
  /*
  This function is filled out in the language defintiion, One long
  switch statment that emits the tree node. It is called 
  each node visit. Or tiny little objects that invoke a few functions.
  The AST node tree, breaks items down recursively, mainly complex
  expressions are there waiting for the if, switch or other designed element
  dreampt up. The walking process, reading, and parsing process 
  are taken care of by this system. The one function, needs to be filled out.
  Some functions for expressions can even be copied. Giving the large list a list
  already made.

  Ultimately it is what is inheirited from the prior language. The initial focus
  would be to incorporate the professionally developed recent langauges such as go 
  and also rust. cython and python. the v8 engine for javascript. and java. As well,
  there are some versions of java that can emit to llvm. The specifics of the entire 
  platform, as a stack machine makes it optomize well for assembly and operations. A
  first world wide placement of gui, and language for multiple platforms. Some of the orginal
  technology was developed at the ivy school level and labeled as a retargeted c
  compiler, a type of script system. The implementation was utilized in a popular videogame.
  Later this technology was used as a more advanced jvm. The ability to include java as
  an llvm target is possible for static compiling system code. An oppurtunity exists to
  speed up java by placing functions inlined instead of elaborate nests of object function
  calls. 

  The possibility of linking multiple languages together as one runtime, or object 
  system from modules is possible. Ultimately some features of languages are 
  upgrades. The provision to provide these languages with operative libraries 
  of gui control is a goal. This can be applied in multiple ways. 

  1) modules and api tailored for sysy output and input modeling, dom access in python may be 
    able to be described in less space. 

  2) Parsed at runtime, possiblity of errors. The ability to tie data that may be modified
    using natural syntax, as if variables are stored within the dom, data is important. The 
    object attached tailored to display and format buffer, or single.

    Tailoring display around string only, provides encapsolation and ease of interface. A token
    transfer of string, or formatted object as a string. Objects therefore are attached as a 
    dom node tree.

  3) binary stream input, as per database_t object.

  4) Compiler pass, or integrated as a compiler function
     translating markup to compatible code. The linkup
    allows placement of data, arrays and maps within the tree.


  */
  virtual void fn_visit(ASTNode *node, LLVM *block) = 0;
};

}