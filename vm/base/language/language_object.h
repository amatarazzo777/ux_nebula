/*
 * This file is part of the ux_nebula distribution
 * (https://github.com/amatarazzo777/ux_gui_stream).
 * Copyright (c) 2023 Anthony Matarazzo.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */


/*

The base language object, all parser derrive from this functionality to 
have much less code within their source tree. For example, all parsers
for every language can use the file input, memory input, token to ast node,
Generalized AST nodes, such as function call, object call, import modules,
text rendering, document building, file system, time formating, user interface,
network protocols, databases, etc can use the same or functional base. The 
ability to functionally operate on calling objects and calling conventions 
using the ABI. Supporting template typed inlined algorithms for building block
application requirements, vector, array, searching, sorting and memory management 
as an inlined resource. There are better and more efficient means to utilize 
the connections, no error checking at all can be faster. This is one reason
null was placed into the world. If a CPU could advance index position, 
repeat a number of times faster than checking for the condition each time.
Automatic advancing by after use signaling is a type of circuit design. The 
processor only mimics this. If the logical gates between the layers of memory,
bit with carry ALU, compare happened because of their known status next, decision,
as hinted by the previous instuction known at compiler time, the comparrison already can 
be completed. Therefore a hinting series on statement context changes from
programming languages can also instruct the flow of machine operation better. 

Many times the workings of algorithms and the styled language offer poor performance.
Even as a programmer, people would not want to design things this way because of 
best practices and maintain ability solutions. Yet For example, many types of thread 
signaliing against a list can increase searching work, where some of the participants
waiting for the signal are near within the current search. By dispatching to neighbors
this information, some types of searching speed can be increased. 

Mutex and multithreaded programming with memory management and UI, database etc. Thread 
pool and interface abstraction to using this concept is easy. Thread pool manager has a 
metric for balance, low and high. The low number of threads is known to be available.
The high number is limit before signal wait. Each algorithm step needing work is added
to the queue of the thread pool manager. It has the abstract interface and within the 
c++ class has the function filled with multitasking. Often types of objects perform
certain types of work. One called PDF, Dta, Report, etc. As parameters, the constructor
adopts the object to utilizing those resources. The resources must be locked while 
reading or writing to them. Mutex provides this functionality, while signal wait provides the 
fastness of immediately starting after an update. For example the thread pool manager would 
continuing looping and then wait until there is no work being requested in the queue. Advancements
in system processes of thread pools can even tie two together before proceeding to the next.
 Logic processing is a described, modeled and then generalized.

 Languages can also use the AST and BISON facilities along with this to make languages inside their 
 language. There is another parser, that is written java, named ANTLR4 than also produces
 parsers. So it seems that perhaps a specific implementation that utilizes the knownledge
 of parser generation, and increases the performance.
 
 That is writing a bison for a language advancement, and use the AST builder, llvm generated
 assembly tokenizer, with a single visit routine in the language implementation. To minimize
 language and provide filling out requirrements typical, of building user defined types 
 that operate with objects or api inside the language. The facilities, once
 installed are available as a temporary resource, or as a system language. Perhaps security
 is of one concern and language dissemination. Installing it as a base language, may be improper.

 Often languages do not get developed because they are for a small pertinent purpose. Requireing
 specific focus in a field, such as described. Yet as necessary, the ability to automate the 
 process from one form, provide language building constructs to include, and establish also
 linking to the visitation. This consolidates functions and real time language creation narrows 
 the field. Perhaps it is not a function used all of the time without planning. Often
 groups start that proceed development with specifics of advancements. Coverage of a general
 purpose programming language can be tedious. The recursive node structure of the AST
 and LLVM context provide for a visitation format. The consideral arguments are language 
 specification, and also elemental types. 

 Choice of variable constructs, object calling and inheiritance routes. Defining
 inline algorithms specific to known data type, reducing structure walk through,
 and also cross conversion with formatting. The provisions of solving a
 type of user defined type and its capabilities for container, indexing, and also
 formatting as an inlined resource yet drawn from definition sources is exciting
 in performance gains. There are many reasons this has not been done in the past
 primarily due to the ease of LLVM and register accountability. 

 Languages define often a structure for memory protectiond, or other relationships 
 that guard against syntax. The proclaimination is not necessary often in binary
 machine code. Simply the logic produce from the assembly does not contain the 
 regarded operations as sought by describing in the computer language. So the 
 construct of the running program can operate witout error checking of this sort.
 Global variables are the mainstay. The reduction in stack and heap space
 are often refferenced in garbage collection. An effective logical 
 path coverage through the program can progressing find variables that are 
 inline to be utilized many times, or have multiple states in a stack. 



 A very important concept of performance settlement at the level, is data and 
display transformation, data formatting, and creation of linked document object model.
Using the XSLT and XML methodology for a starting point, the formatting and display
of data, interface objects, and events have to be infused with the data. As a known
of editing, or display, formatting, with shape draing, shading, image processing,
communicated to the pipeline. Templates do provide the unraveling of the object.
Notible Element, and types of behaviour associated with it. As a structure, class,
creating it within the language as LLVM developed structure, could mean usaing 
several select methods. The necessity of developing a lower level, interface
for the display and rendering to be written in c++ using only structs, and readible
known formats. The element structure has node access using raw pointers. Most
structures such as style and attribute, can also be inscribed. As a facility,
the calls to specific types of rendering technology through native ABI and raw memory
is compatible with BC coding. Therefore, integration of a system to document trees
and language implementation can be selective and also high performance. This adds to 
the design, but strengthens some code bases such as the base document object model from
c++. It utilizes its own interface layer to native language integrate to the new 
raw memory compunent for language filling. 

When the tri compund of multiple types of algorithms working together, often knowing the 
bounds of search provides efficiency. For example string searching using regular expression
is a known method. It is sometime tedious to develop large matching patterns. In this way
bison is more advanced. The ability to develop a parsing engine that is efficient and 
will link to inheirited and described language features using the BISON format provides
efficiency of LLVM. The parser made for memory buffer only.

The ability for operators and statements to be communicative with the inline algorithm
production facilities provides a means to companion emittances of the operations. A production
facility is also to deviate from the prescribed calling conventions internally such that 
protocol endeavours may be made possible. The design should allow for during emittance,
the operator for the algorithm, adjusted for parameter usage, data type, will also include 
added types. For example, the amount of calls for data and time, as a numerical representation,
can be verily reduced as an inline advanced data type. Distributed in all systems even storage.
As a base date/time numeric with a designed output format integrated, inline compileded using 
recursion for set formats. Ingregal information qualities extrapolated, and bit wise manulipated.
Outformat also has length stay with the Local setting. 

Number formating and advanced rounding storage types, integrated with the assembler. Formatting
routines with sizes and DOM node compatibility for styled inheirited display, target built.These 
things never change in the display necessity. If one writes the code to change over also,
in the language, then that genetic code path will contain the genetic type. Merely providing
the facility provides the fastest build up method for select.

Every boolean in the entire land, changed to a bit could be a target for program. Although
memory contention could arise from several threads a program would create and expect memory. 
Too bad.


The compiled programs are going to be attached to a document object model, already made
where epilogue and prolog code interact with the device or operating system. Simply
the structure now is one c++ box, with the systems embedded in one project. If everything
links down to the base_function_call stack, the API for applications as a direct
memory structure that is read only, one would want to design the base
platform as such. Most of the provisions of the applications should be 
alloted for types of protected access. There is a handful of useful
API, and many subsequent systems embark upon creating summarizations
aut automations of these. In this, base systems have a root to be named well.



The database system, precludes all storage formats of structure system wide.
No more text user settings, network settings, or text driver programs except
language. The file system, and database system are perhaps types that 
are genetically transcribed to run within a checked context. Yet at this level,
still using the opened file handles that are native to linux can be functional.
Yet opening and closing the file associated with a restriction on application layers.
For system use, perhaps it may be performed at a low level. Device driver
implementations for better throughput. 

A genetic template language for algorithm description that can be utilized
with llvm is necessary. Otherwise the stack of calls to embed calls to other systems, 
in sequence for a process becomes tedious. Algorithm description and data
types. The language will have no display or network capabilities, formatting of 
string, numerics, floating points, time, date, and also c++ dom all toegether
in one format, and template for creating inline data types.
*/

namespace viewManager {
  enum_algorithm_t {
    data_type,
    inline_data_type,
    api_call,
  };

class computer_language_abstract_t {
  std::vector<std::string> lines_of_code;
  ASTNodes *node;
  std::vector<std::string> grammer;

  // ast nodes with inline genetic algorithm for variables,
  // handling vector, list, unordered map, ordered map, nad partial search map
  void emit_object_type(ASTNode *node, enum_datatype_t a);
  void emit_object_type_inline(ASTNode *node, enum_datatype_t a);

  // api call to c++ base.
  void emit_api_call(ASTNode *node);

  // an inline system kernel call headers found i nthe <sys> directory.
  // the includes, advanced features of the file system, process,
  // thread, mmap mapfing a file to memory, shared memory,
  // scatter gatter io, and socket communication and pipes.
  void emit_inline_posix_call(ASTNode *node);

  void emit_document_object_inline(ASTNode *node);
  void emit_document_object_inline(ASTNode *node, const std::string &markup);
  std::size_t emit_create_memory(unsigned char *b, std::size_t size, bool bmutex);
  std::size_t emit_create_object(unsigned char *b, std::size_t size, bool bmutex);
  void emit_free_memory(size_t id);


  // generates an llvm component for the BISON language, 
  // can be a cached object of machine code for parser. 
  void gencode_grammer_tokenizer(void);

  void generate_parser(void);
  void generate_build_system(void);
  void generate_source_indexer(void);
  
  /*
  This function is filled out in the language defintiion, One long
  switch statment that emits the tree node. It is called 
  each node visit. The walking process, reading, and parsing process 
  are taken care of by this system. The one function, needs to be filled out.
  Some functions for expressions can even be copied. Giving the large list a list
  already made.
  */
  virtual void fn_visit(ASTNode *node, LLVM *block) = 0;
};

}