/*
 * This file is part of the ux_nebula distribution
 * (https://github.com/amatarazzo777/ux_gui_stream).
 * Copyright (c) 2023 Anthony Matarazzo.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 3.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

/*
Databases of a local nature, reserving the right to have a pointer
to records, a record or a field that is tracked perhaps. Node and
pointer storage database with memory allocation on reload. Index
building, partial index building. Record block saving.

SQL, and tasDA. SQL processing. Remote. Already written materials.
Transfer local database to remove, leave file, keep cache.
Integrate with larger databases of different type.
Later sync. Every x sync. The format can transfer to these database
formats.

Used and adapts to size. Memory databases to scale remote and local.

A person writing one would consider that the visitation of node map
of the trees, as a unit stored on disk and the edit commands are 
also suitable for network. Using a file and types of locking a certain
size of file can be accomidated. Supporting advanced searches
along with index data gathered from blob indexing (videos, images, texts, books)

The blocking mechanism provides for adjusting the components of a larger database when it
is broken up. Simply records tell the segment starts and stops. Indexing files can
use this and operate on a parrelle fashion. Adding advanced node storage is versitle,
however providing for a stream and easy location system for syntax is also nice.
Being able to store vectors of structures. 


Template parampack parameters <...> can be used in conjunction with type to for types of 
record schemea, as is the type of conception format. The storage of nodes, and variable nodes
of children. Some problems to solve, but should be a fun project.

Simply placing a marker file, and uploading this file to a server program will allow format reading.
Security is a concept not made here, typically user security. Or over encryption.



For a database link, it is a information part that can be easily updated. It also contains links to 
server addresses, will develop the connectivity for legacy formats, or` other file database formats.
odbc, jdbc. The database link here is also used for access to image data that was gather from news 
feeds for example. Video links. and provide a display format for the cached news xml feed.
Google XML search cache results from a data mining bot app running locally. Typically the file
system has multi user locking already built in. 

The database format can also be used for the desktop, and user application storage. The format works
better than many database competitiors. The update process from version to version is realitively 
quick when a programmer changes the data storage format or types of data. Importing can be done once,
or when needed. Most times done once is fine. Well planned applications update not as often. The
contact and email list. The listing of programs installed on the computer will use this data
base storage. as a system database, used by the operating system, perhaps networking will not be built in
to the library, the great dreams of SQL, and syncing left for the application
style database that inheirits this model. 

The database may be adopted for the object name database, and internal system usage. Therefore
making the usage, for structure storage, objects and also searching, function visitation 
can reduce code on usage and also specialize systems to invoke streams of this nature. That 
is as a remapping data target, from storage to memory, document object models can be saved
in the format. Providing for a streaming service.

The desktop can use this facility for memory of programs, desktop settings, visual rendering settings,
known wifi signals, etc. So the tempation is to create a system that is larger. Perhaps minimizing
the usage to templates provides the most effective storage means. Error free when the 
database engine can perform single user works. In memory. mutex can offer record locking for multiple
processes.

The facilities available as an inline algorithm in various languages can be a wonderful task.
Making the data storage contain only data, while indicies are stored in another area is fashionable.


An interesting aspect of the linux system is that it keeps track of sparse data, and 
using this effect along with directory structure is interesting for database. The utilities
that exist such as tar, gzip, and directory compression algorithms can provide
remarkable compression for data structures, and information systems in text files. zip and 
store as a token block along with index. 


Using the database system at the device driver layer for even file system,
can be effective for some types of base usage. Yet more likely a
system that some of the techniques for data storage, and chaining. 
Using more storage space for dynamic file types of 
user and program ownership. As a node inheirited facility.
Enabling better index storage, and compression by knowning storage format,
and having system codecs related to the blob. For example, specific
databse formats that encase knowledge may be large, and types of index searching
built for node traversals based upon a floating point. Or a series of 
other branched statistics. Perhaps initially designed as a file,
yet programming intelligience for a specific operation such as local image 
OSR for users at their desk. Voice recognition for their user. These components
produced for their system by a server software can offer better performance.


The database system is versitile, yet as a template class, providing a delicate way
for multiple types of data to be stored in a file. Later loaded and represented as the 
same memory structure. The ability to reutilize the functions, as a memory, or partial memory
system can be within the design. The ability to store directory information, and also access 
index information in one file format. The database_t object is a small yet functional 
part of the system. The system_database_t is a local file dataobject. Databases
can also be representative of multiple formats of data such as image, text, scripts, movie frames,
3d models. While not stored in a streaming format can be applied to balance
several field record types of image, etc. to a local databae across the network. 

The database can store the scene graph object. A file loaded to produce a snapshot of the 
3d context. The video format.


Some uses of PC component technology as a node cluster for receiving data at speeds of the 
front side bus, acting as node storage device recording the ID and sample data. Quantum
sensors plasma engine designs, require more discovery. Many fiends of science have to rely
on older methods of computer software development. Python is luckily running on large super 
networks. Yet all depend on the console. 

Yet the ability for a high end intel server to receive a max of 60 gigs of data, write
it to a high speed drive, or raid array. Perform node database clustor work as well. Analysis
on data. The ability to functionally load a scientific datacenter operation with scalinging 
storage and analysis. May not be suitable for some types of work. 

Types of database mechanisms can be more self discovery aware on disk and also apply an 
very beneficial use of object technology. More advanced than just data storage. Imagine 
the same database mechanism working cross language, multi user for system tasks. 
Perhaps a database will be queried for items such as hardware.

The ability to have multiple databases, yet not relating them together would also
be ineffective. For example, object systems of specific domains, such as text edit,
and also calendar. Both controls so apply them to the control registry - or database_t
system file. Yet the process of adding multiple other types of objects becomes
difficult to address as one name. Simply dividing the object types into various
databases. Yet as a complete system being able to capture each database,
in a type of search, or query for how it relates to system functionality.
And combine the information into another location. Applying a link to this data.

A system where system preferences, object operations, desktop defintitions,
 and user data are captured. The format open, versitile, can be updated and 
 also tranferred. It has to be transfered to a software base that 
 will understand what the settings and structures mean. Often requesting
 that a parser be in place, does not solve software usage.

 When databases are created, a bitmap numeric locates the database to a specific system type.
 In systems, these types can be summarized, and also analyzed. The database system also 
 supplies bucket processing in its api desgn, to enable selection, while also providing
 a weighted means to choose the best quality fit for an object. This may be useful when two
 objects ocupy the same namespace, yet the calle is expecting a specific object.

 One type being a user type, for allocation to the user domain. 
 A system type can be registered for planning as a centralized data storage registry for
 groups of objects. Types of controls, or editing controls. Proviging a heirarchy, and 
 inheirtance for objects. 
 
 So as a central registry, all controls on the system can be inspected. Each
 contained within their database. Central object registry is not needed for all databases perhaps.
 File and directory scanning can locate data.  

*/

template <typename T>

class data_node_t {
  T *node;
  T *oldNode;

  std::size_t location;
  bool bchanged;
  uint32_t tuple;
  /* allows alias for non related application technology, same as pointer, in
   * scripting or database to screen linking by id, tuple may be appropiate.*/

  std::size_t get_data_size() {
    if (constexpr std::is_base_of<std::basic_string, T>::value) {
      return node.size();
    } else if (constexpr std::is_base_of<std::vector, T>::value) {
      // ways to use sum()
                    return sum(std::visit(node.get_data_size());
    }

    // if nodes contain compound types such as vectors of
    return sizeof(T);
  }

  // indexing function, used by the query engine for sorting.
  bool compare_greater(T *_rnode){return *node > _rnode};
  
};



class database_t {
  public:

  /*
   a specific index.  location by varying index operator. 
   objects into the system  can be hashed together to find any 
   type of index. Providing a remappable node list for any type 
   of indexes. As a format it can be a high level format for 
   types of standard template library. As well, encompassing 
   dynamic indexing, and searching, related nodes.

  */
  template typename<T, ...> operator[]::(T, ...) {

  };

  template operator<< {

  };

  template operator>> {

  };
 
};


/*
@brief When databases are stored on the disk, or network in a file,
these are the types of blocks the datastream can have.
The header is the first block in the file. The header
also points to the directory entri table. Where possibly
multiple objects exists. When data, index, directory, or
tuple space runs out because of editing, the chain block is used to
point to new informaiton written in freespace.*/
static class enum db_block_type {
  db_block_header,
  db_block_index,
  db_block_data,
  db_block_tuple,
  db_block_directory,
  db_block_chain
};

/*
The type of system database file. This information is in the database header.
The database file format replaces the application modules and also program
type from the standard linux api. The system functions start_process, and 
also fork, are wrapped with the database reader. The program reader
applies the same methods as the system api. Eventually the format readers 
should be included as part of the OS.

The db_object provides a non mangling namespace to identify prototypes
and interfaces by integer reference. Objects within the newer format 
can be applied to multiple languages and also container types. Essentually
the object operators, hashing mechanism, and a few other routines are utilized.
The prototypes and calling interface mechanism are described. 

The language object provides a standard mechanism for using compilers on the system. 
Languages can be dynamically built. The object file format encapsolates the 
cache and also other parts of the programming language. The object is 
tailored to work with an IDE, or multiple IDEs that can utilize the format, programs.
Source code, or compacted sealed source code, can be compiled.

the db_index, and db_data are for storage of object data within a node list.
The data may be read, while the structure is preserved on file as well 
as in memory. The formt provides an mechanism for query.

*/
static class enum system_db_type {
  db_program,
  db_object,
  db_language,
  db_index,
  db_data,
  db_document_tree,
  db_document_transform,
  db_directory,
  db_composite,
  db_font,
  db_brush,
  db_image,
  db_audio,
  db_scenegraph,
  db_video,
  db_shape,
  db_registry,
  db_symbolic_link

};


template<typename T> class database_file_t {
public:
  struct header {
    static float version = 1.0;
    system_db_type dbtype;
    std::size_t free_storage;
`  };

  class relative_chain_t {
  public:
    static const std::size_t stamp=0xff11;
    u_int32_t block;
    std::size_t position;
  };

  class relative_freespace_t {
  public:
    static const std::size_t stamp=0xff10;
    std::size_t length;
  };

  class edit {
  public:
    // visit for the nice record  edit of large texts, or parts of images,
    // blob data instruction edit of binary data. Font texture update because
    // of antialias smuge. the chain block, writes the signature and adds to free storage.
    //
    void visit(std::ostream _odbLock) {
      switch (editType) {
      case _tupleExpand:
        // write chain record and update free storage space with the in space
        // connected. some types of data will expand and leave the orginal
        // black. This occurs when the space on disk for the oringal data of the variable length
        // blob (string, array data), that at the point inside where it is compacted, 
        //or at the beginning making the entire block a hole. chain does this and updates
        // the header. If this does no
        chain(_odbLock, e);
      // clears a space usually at the end due to a delete, data residue.
      // the space is not acually cleared, but tagged as removed. 
      case _tupleClear:
        _odbLock.fseek(relative, e->location);
        _odbLock << relative_freespace_t{e.size()};

      case _tupleWrite:
        _odbLock.fseek(relative, e->location);
        _odbLock.fwrite(e.data(), e.size());
      }
    }
  };
  std::list<std::list<std::uniqur_ptr<T>>> node_list_t > data;
  std::list<std::uniqur_ptr<T>> changed;

  void connect(std::string cs) = 0;
  void disconnect() = 0;

  // has the position on disk realive to a marker. The match tuple structure can
  // contain extended information. The edits buffer contains valuable time
  // saving buffer edit connands. Network reduction only sending the changes to
  // the monster 300 page novel, fifteen pages deletes, two words, paragraphs,
  // move,  etc, words and additional pages.
  void update(uint_32_t tuple, unsigned char *edits, std::size_t size);

  void commit() {
    if(t!=0)
        std::throw("invalid nesting of transactions.");
    for_each(n : changed) {
      odb.fseek(absolute, n->location);
      if (b->bedit)
        std::visit(odb, n->edits);
      else {
        // new record, insert record, or update not needing edits just over
        // writes, changed numbers, etc.
        odb.fseek(n->location());
        odb.fwrite(n->data(), n->size());
      }
    }
    odb.flush();
  };
};
}
