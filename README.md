# vm

This project is a research API for the C++ 17 and above language to provide a document object model. 
The product is designed to be cross platform. 
Currently the macOS, iOS, and Android NDK library needs research. The template dom library works 
precisely with the standard library without adding new data types. It supports rapid development and 
incorporates a small set of memorable names within its model. It is a templated oriented 
implementation for higher performance and integrated syntax. It offers the document 
object model integrated with C++ language as a natural syntax that appears like HTML because of the use of <>.
The following development platforms and rendering technologies are capable of use for development and distribution.

Research into method of invocation of newer font systems that do not utilize external sources. Better projection,
and art amazement with the coloring of vector fonts. Natural and logical soft font sizes and enhanced rendering
that is solved algorithmically. 

Development of kernel loading, from package sources, compile and handoff to graphic image for video driver loading. 

. Automated image mixing with transparency in layout. Text can reside in non square bounds and overlaying images.  Polygon flowing areas of text.
Graceful character glyphs with built in styles. 

Working on a method whereby the entire device chain can be rebuilt on the linux kernel for GUI management, application model, object model, and system API. Languages and also desktop OS for software games working on newer embedded processors. 

Research into a stream format for information and data entry fields. The SGML definitions change according to scope. 
The main perspective is tailoring to audiences for a type of writing markup. Maintaining a user domain focus for select 
ages. 

<ul>
<li>Microsoft Windows
<li>Linux
<li>macOS
<li>iOS
<li>Android NDK (native development kit)
</ul>

Supported C++ compilers
<ul>
<li>Microsoft Visual Studio
<li>GCC
<li>clang
<li>Objective C
</ul>

Rendering Engines

There are numerous possibilities for the model's occupancy within the developerâ€™s toolbox. 
The system provides these capabilities through well documented preprocessor definitions. 
That is, compiling for each of these types of environments is established as simply turning 
a definition on or off. Some of these project types require third party libraries for linking.
Optionally linking can be static or runtime dynamic.

<ul>
<li>Embedded internal
<li>Embedded external
<li>Embedded advanced image processing external
<li>Cross platform Desktop application model
<li>Cross platform application model with advanced image processing
<li>Qt client cross platform Dom
<li>GTK++ client cross platform Dom
<li>WxWidgets client cross platform Dom
<li>Chrome Embedded Framework
<li>Gecko Layout Engine
<li>Windows OS specific 
<li>XCB Linux Application
<li>X11 Linux Application
<li>X11 Linux Desktop
<li>Android OS specific
</ul>

      #include "viewManager.hpp"
      using namespace std;
      using namespace ViewManager;

      #if defined(__linux__)int main(int argc, char argv) {
      // handle command line here...
      #elif defined(_WIN64)int WINAPI WinMain(HINSTANCE / hInstance /, HINSTANCE / hPrevInstance /,                   
            LPSTR lpCmdLine, int / nCmdShow /) {
            // command line
       #endif 

       auto &vm = createElement<Viewer>(
              objectTop{10_pct}, objectLeft{10_pct}, objectHeight{80_pct},      
              objectWidth{80_pct}, textFace{"arial"}, textSize{16_pt}, textWeight{400},      
              textIndent{2_em}, lineHeight::normal, textAlignment::left,      
              position::relative, paddingTop{5_pt}, paddingLeft{5_pt},      
              paddingBottom{5_pt}, paddingRight{5_pt}, marginTop{5_pt},      
              marginLeft{5_pt}, marginBottom{5_pt}, marginRight{5_pt});  

              vm << "Hello World\n";  
              vm.render();
        }



The use of exterior words apart from the standard c++ library often shows some modifications that may be well liked.
To utilize the push_back, delete, insert keywords and provide c++ algorithm support may be over design. 
These functions can be added to provide like STD syntax. Review and simplify if necessary. Adding  these routines in place of createElement.
One may also simply provide call through template classes named like the STD. Does it make the code more readible?
Downfalls?  Here is an example.

  auto e=vm.push_back<h1>({});


Evaluate system design complexity. Less code and more elegant algorithms. How much data should the system be able 
to handle, or expected to handle? The limits of a usable interface should be met well before processing nature
of the machine. Providing upper bounds is important, security of compositions within a window box. 

Because the font system is embedded without downloadable fonts, it depends on less unsecure data. The nature of
X11 transport is created here, as is the rudimentary stream type for information displays transposed from
html web page layouts to a rendering pipeline. Limiting the prospects of ever supporting all features of the 
browser, there can be some types of transfer support for native layout of books, with images, games, etc. Where the 
format is just loaded and displayed. Routines of components plugged in, and simple logic to handle all business needs.
Much more effective than the Javascript language for database entry applications. In fact language definition
and modern compiler design has to advance to support these technologies. The ability to craft simple computer 
language files, plug it into the system and utilize more summarization techniques, encapsolation, offers using
perhaps LLVM. The scope of producing efficient code is seen with c++, yet how much input is required to 
provide these types of results on object oriented designs is difficult to know. For example there are a hugh
number of options for call sites to know about, yet perhaps only a few of them will be used. Use use of AST
and recursion with a tokenizer is how modern expressions can be evaluated. The integrated comparisons and vector types,
memory allocation, rely on stack space. The system says that it uses heap memory by using the system 
malloc. 

The linker must link to the OS libraries to utilize heap I believe. Yet
a feature to design is that linking of an object should be designed to be done completely in memory, such
that the program's internal memory management is mostly the user's choice. Gui memory and other object
data in some system designs can reside within another process space. It is of interest to maximize development of 
transfer options to invoke a container type of protocol to transfer the data without future changes, working with loaded
symbol files that stores a protocol table, for example. As a binary construct, an internal branch structure that supports
dynamic protocol building, and array access to native and compiled types. Objects that function quickly ultimately
must depend on no transfers of data. 




. Yet it is known 
that the standard library is not within space. For example, templates can be designed with select template
query functions that test for constexpr that make allowable code path productions possible. One use is to tailor
the routine around this distinction. There are also other types of advanced template functions that provide
static code polymorphism, testing if a base type is within the inheirted stack.  So for example, testing if the 
container or element supports raw data transfer of its memory location as a size or structure allows it to be 
automatically transfered as a data type to the rendering process. The complete package of data elements within
a shared memory buffer as a whole is best. Parts of it locked and managed. 

So the testing of the STL version and capabilities are evident for some features, more projects in other departments
of system design. new componet systems for native c++, memory linking, container, vector storage. Other types of problem
solvers can utilize protocol style buffers to develop reall time call site mechanisms to versioned interface objects. One 
hugh problems with object growth style is too many interface changes, outdate functionality. The loading of a binary foot
print within the .so file that is selective while other parts are not needed is useful in updating linktime components.
Thereby agreeing to a level of depreciation.  Interfaces often grow to add support for functional updates in other industry
areas, and then are modified to technically be ineffective, and altered forms are adopted in the future. Simple changes that
can be described through comparrision and analysis to promote automatic updating of software is advanced. A C++ program 
that runs in the future, as adopts a liked interface portion, style, control pallette, has to be planned well. One remark is
that in such uncompromising circumstances where all cannot be provided, is that generalizations be in place. 

One focus of HTML brand is that within the group of writers, one expects ordinary writers to accomplish the tags. 
There are all sorts of tags flying around, yet as a writer's some do provide sense. The ability to more accurately 
define a useful layout language that also inheirits a names space such as academic MLA, or Universal Addresses, or 
Control Patterns makes better building block sense to expose the browser's layout technology. Therefore the mode
of the page tags should offer exciting possibilities. The usefulness of this supplied within this programs is to
test also if it would be able to be reutilized, add tags, and redefine styles. Element, reuse capabilities 
is essential. Offering a useul consolidated approach to audience style writing, and modes of writing can be useful
to many people. This method of template C++ provides this easily, enhancements to provide better inheiritance support
is useful.

Programs that try to crash the system with all types of obsecure work, some resulting from errors, invalid data,
 should be crafted. Building a system full of error message is execellent for business systems. Yet routines that 
 are within a domain of logic can be expected to operate without errors on input. In low level algorithm programming
 it is often necessary to skip error on input to achieve throughput. 

While the code is built based upon nomenclature HTML basic tags, to invoke. Modifying the c++ template to 
yeild placement into a raw pointer node tree can be useful. The task of pointer management of this kind has 
been solved manytimes before, problems do come again. As a enhancement, moving away from small token within
the function namespace to a well spell out method tends to offer programming companionship. Such as 
instead of createElement<H1> to using more of a c++ street legal academic terminology, to 
createElement<H1_t>({}), or createElement<heading_t<1>>({}). Moving away from some condensed forms to more structure.
These questions should be prized.

Booting from linux and designing an Application framework for items does have its direction. As well, traditionally
working with the elaborate and well known windows API has a winning combination. As a library that can be lifted to
place in other languages through parse invocation offers multiple running platforms. 

Designing edit components was a shift in methodology to craft them in the pure browser languages. Yet as a mixture,
native and new controls should rely on object oriented inheirtance. The work of entering a character, designing a wisiwig
document editor, and the like has become embedded solely in the javascript world. To build a system that can provide
extensive editing features, grammer, spelling, and the consumer versus business audience publishing is well deserved 
in designing as a base feature object. Therefore component engineering to supply the longevity should utilize the mix
component rendering technology. 

forms of gradient definition within the color tag. Color should also support 
   image, etc. Perhaps the system buildup will include an object that simply encapsolates
   the entire engine as a stream context with a discrete focus on types of functionality
   that are plug in based. As a reusable object, with an encoded binary stream input 
   for function invocation breveity. A stream with graphic database file loading. Parts of the 
   stream exists to instruct the dynamic alteration
   of the graphic asset in multiple forms, even over time. For example, making a series of 2d curves
   shaped differently as its beautification attributes are used. 
    The ability to set up a rendering chain that is complex with
   multiple types of compositie graphics, and animation layers is a easily adopted figure.

   Especially within the color tag, gradient producer, or effects. As a friend class of the 
   nodes, inspecting the analyzed output from 2d vector queries, quadrant area signifigance, blending,
   and unification within the animation aestitcs provides effective display capabilities. 

   Provide smarter management of language rendering for English, Spanish to use the first 255 bytes during 
   character reading, writing and storage. Provide a flexible structure to utilize also rendering of all
   language characters. 


 Many have tried before and simply decided to increase complexity. Yet as a font object, can more intelligent decisions be
  made by the system as a group. Typically the infustructure of font systems, as a granular focus, offer pop, push and stack instructions
  The effectiveness of rendering nicely solved by vector data and pure code on the other side seems inviting. As a tailored approach using
  less data, intelligent processed letter, word, and advanced quick raster data moves. Often details of this nature might be three pixels for
  normal reading texts.
 
  New designs that provide automated effects, shadow, ligature, types of paragraph style.
 
  Because all font systems in current form have a copyright, the c++ language does not have its
  very own. rendering of graphical texts with an abstracted framework is about the
  closet native that will happen.
 
  To start simply from the drawing constructs of pure vector to raster layer encompasses allocating resources for
  	storing the rendering.
 
  	what to draw at what location or code is strictly left up to the design, yet to encompass data transfer,
  	using the unicode table for ascii, or other.
  	To simplify existing font system data and use it, ones that are free by license to start, and then
  	when sales hit a royalty for their protected asset. The font data, hopefully vector coordinate data for
  	drawing functions, can be magnified as a source for input. using the system data in a one call text render with
  	a buffer, stride etc for traversal, and color mixing.
 
  	As an engine with data only, analyzing the vector data, textual input, raster and fill the block with integrity,
  	readability, and performance for optium color or shading. Utilizing the space, aware of language, with minimal
  	data such as vector data, Within most data sets for the glyph, data exists such that informs the box adjustment
  	to actually blit at, the base line.
 
 
  	 a rendering speed up is the focus is using the next and previous character within the routine rendering's scope.
  	 Typically a large context of data, or perhaps consolidated in large nested loops works even better with the
  	 added complexity of another loop on the outside. The data is composed to form a outline and an image.
 
  	 The ability to reuse the font data, once a medium surface has been found to transform the geometry makes
  	 the font engine powerful to develop multiple other font variations. The font glyph object itself can have more data
  	 associated with it to utilze a system of movement. For  example, on the capital letter A, one can see multiple
  	 position where a font designer or algorithm would want to modify the shape. The cap, top point can be
  	 more pointed or rounded. The middle bar can be raised or lowered. As well, raising one side higher. And the angle of the
  	 of the two vertical slopes. One can easily establish a variance detail for the shape of each letter.
 
 
  	 The ability to use the vectors to apply deformations to characters based on analysis of the path data set,
  	 and measurements of beautification points. The middle, the top half, etc. Corners. The problem that is trying to
  	 be solved is font variation based upon metrics, and even word meaning.
 
  	 To captivate audiences with subtle produced surfaces that envelop the characteristics of a letter shape, english
  	 is a form that remarks. To use contextual meaning, letters, and other attributes, analysis of the context for
  	 the document status has to be known. The type of application, where the text is being rendered, a type of genre
  	 for externalized bitmaps. Using 3d transforms on the letters
 
  	 The textures placed on the modified to convey subtle 3d characteristics and also lighting.
 
  	 effects that are vector based yet apply analyze data from character, word or selection for effect. Procedurally
  	 reduce effects to data input for rendering engine enhanced fonts. That is effect one word. Effect a list with ten ul elements.
    compact animation necessities, sprite, sprite paths, particle system, animation timing functions, texture input. Particle
    positioning can be related to glyph rendering attributes and edges.
 
 	  Another study could be performed to analyze the difference between font styles that are of a distinct quality.
 	  I presume that the readibility of the character could be defined to vary  amongst the points where family
 	  font vary.
 
 	  A specific proposal for vines and types of patters that work well with some types of writing, or letter styles.
 	  To use fine curls on tips or letters such as J, making the inner curve loop is a remark relating to the letter
 	  shape.
 
  	  Provide frame buffer export.
 
  	  shape carving from 2d.
 
  	  To logically analyze the uses of 3d rendering of text for approximation of use. The variance of
  	  blending and background shadow, and texture versus screen real estate and pixel dpi.
 
  	  Using small storage and initial load rendering is fashionable to encompass font engine technology.
 
  	  The ability to strategically use statistical data from the shapes and form natural flowing
  	  meaning for baseline is fine. Although a simplification in data storage.
 
  	  Creating new fonts from a template and applying specialized and well though out deformations. The ability
  	  to construct the letter is present, yet a default exists that provides building. A dedicated model for
  	  transformation. For example the thickness and thinness across the group. The height at various points, stretched.
  	  A radius expansion, etc. The ability to adaptively weight  the zig zag effect around the edges. So with a refined focus
  	  of software transformation to the glyph the uses intercede having an extreme amount of font data.
 
  	  Embedding the font data within the binary executable is very possible considering the small size of vfont data. The program creates new fonts from the selected base standard.
 
  	  Application icon library. Material icons are at times for the web. Developing a natural professional function icon set
  	  for The engine to utilize as grey scale icons for user communication. the folder, file, picture, tree icons,
 
  	  Flow charting and logical definition font with editor.
  	  To store a process flow visually and use design and plug in code from other authors.
  	  	some points are textual and others schematic computer code.
 
 